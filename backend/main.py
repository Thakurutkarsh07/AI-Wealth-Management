from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv
from chains.query_router import route_query
from chains.response_formatter import format_with_gemini
from utils.sql_runner import run_custom_sql
from chains.sql_generator import generate_sql_with_gemini
import uvicorn
import json
import re
import os
from pathlib import Path

load_dotenv()
app = FastAPI()
CACHE_FILE = "cached_insights.json"

def load_cached_insights():
    if os.path.exists(CACHE_FILE):
        with open(CACHE_FILE, "r") as f:
            return json.load(f)
    return {}

def save_cached_insights(data):
    with open(CACHE_FILE, "w") as f:
        json.dump(data, f, indent=2)

# CORS setup
origins = [
    "http://localhost:5173",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

def clean_json_string(s: str) -> str:
    return re.sub(r"^```json|```$", "", s.strip()).strip("` \n")

# ----------------- /query endpoint -----------------
@app.post("/query")
async def query_endpoint(request: Request):
    body = await request.json()
    question = body.get("question", "").strip()

    headers, rows = route_query(question)

    # Fallback if rule-based routing fails
    if not rows or (headers == ["message"] and "couldn't understand" in rows[0][0].lower()):
        sql_query = generate_sql_with_gemini(question)
        headers, rows = run_custom_sql(sql_query)
        print("üîç SQL generated by Gemini:\n", sql_query)

    raw_response = format_with_gemini(question, headers, rows)

    try:
        cleaned = clean_json_string(raw_response)
        parsed = json.loads(cleaned)
    except Exception as e:
        parsed = {
            "summary": "‚ö†Ô∏è Gemini response couldn't be parsed.",
            "table": {"headers": headers, "rows": rows},
            "graph_suggestion": {"type": "none", "labels": [], "values": []},
            "error": str(e)
        }

    # QuickChart URL
    if parsed.get("graph_suggestion") and parsed["graph_suggestion"]["type"] != "none":
        chart_type_map = {
            "bar_chart": "bar",
            "line_chart": "line",
            "pie_chart": "pie",
            "doughnut_chart": "doughnut"
        }
        labels = parsed["graph_suggestion"]["labels"]
        values = parsed["graph_suggestion"]["values"]
        chart_type = chart_type_map.get(parsed["graph_suggestion"]["type"], "bar")

        chart_url = (
            f"https://quickchart.io/chart?c="
            f"{{\"type\":\"{chart_type}\","
            f"\"data\":{{\"labels\":{json.dumps(labels)},"
            f"\"datasets\":[{{\"label\":\"{question}\",\"data\":{json.dumps(values)}}}]}}}}"
        )
        parsed["graph_url"] = chart_url

    return parsed

# ----------------- /insights endpoint -----------------
@app.get("/insights")
def get_insights():
    cached = load_cached_insights()

    # Historical MySQL queries
    top_clients_sql = """
        SELECT client_id, SUM(value) AS total_value
        FROM transactions
        GROUP BY client_id
        ORDER BY total_value DESC
        LIMIT 5;
    """
    top_stocks_sql = """
        SELECT stock_name, SUM(value) AS total_value
        FROM transactions
        GROUP BY stock_name
        ORDER BY total_value DESC
        LIMIT 5;
    """

    headers1, rows1 = run_custom_sql(top_clients_sql)
    headers2, rows2 = run_custom_sql(top_stocks_sql)

    def format_graph(headers, rows):
        if not rows:
            return {}
        return {
            "type": "bar_chart",
            "labels": [row[0] for row in rows],
            "values": [float(row[1]) for row in rows],
        }

    historical = {
        "top_clients": {
            "source": "history",
            **format_graph(headers1, rows1)
        },
        "top_stocks": {
            "source": "history",
            **format_graph(headers2, rows2)
        }
    }

    insights = {}
    questions = [
        "Who are the top 5 clients by total portfolio value?",
        "Which are the top 5 stocks by investment amount?",
        "Which relationship managers handle the largest portfolios?"
    ]

    for q in questions:
        if q in cached:
            insights[q] = cached[q]
            continue  # Skip Gemini call if already cached

        try:
            sql = generate_sql_with_gemini(q)
            headers, rows = run_custom_sql(sql)

            # Limit rows to reduce tokens
            trimmed_rows = rows[:5]
            raw = format_with_gemini(q, headers, trimmed_rows)
            parsed = json.loads(clean_json_string(raw))

            insight_data = {
                "summary": parsed.get("summary", ""),
                "graph_suggestion": parsed.get("graph_suggestion", {}),
                "table": parsed.get("table", {})
            }

            # Add chart URL if available
            gs = parsed.get("graph_suggestion", {})
            if gs.get("type") != "none":
                chart_type = {
                    "bar_chart": "bar",
                    "line_chart": "line",
                    "pie_chart": "pie",
                    "doughnut_chart": "doughnut"
                }.get(gs.get("type"), "bar")

                chart_url = (
                    f"https://quickchart.io/chart?c="
                    f"{{\"type\":\"{chart_type}\","
                    f"\"data\":{{\"labels\":{json.dumps(gs['labels'])},"
                    f"\"datasets\":[{{\"label\":\"{q}\",\"data\":{json.dumps(gs['values'])}}}]}}}}"
                )
                insight_data["graph_url"] = chart_url

            insights[q] = insight_data
            cached[q] = insight_data  # Update cache

        except Exception as e:
            insights[q] = {"error": str(e)}

    save_cached_insights(cached)  # Write cache to disk

    return {
        "historical": historical,
        "llm": insights,
        "note": "Use /query for live AI-powered queries."
    }

# ----------------- Run locally -----------------
if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
